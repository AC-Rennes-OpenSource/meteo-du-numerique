desc "Construire l'AppBundle Android"
lane :build_android do
UI.message("Construction de l'AppBundle Android...")

# Construire l'AppBundle en release
  sh "flutter clean"
    sh "flutter pub get"
sh "flutter build appbundle --release"
UI.message("Build Android r√©alis√©.")

# Extraire la version et le code de version depuis pubspec.yaml
version = get_version_from_pubspec
version_name = version[:version_number]
version_code = version[:build_number]

# Obtenez la date du jour sous forme de AAAAMMJJ (ex. : 24122024 pour 24 d√©cembre 2024)
                    date_today = Time.now.strftime("%d%m%Y")

# Cr√©er le nom du fichier AppBundle avec la version
aab_filename = "MeteoApp_#{version_name}+#{version_code}_#{date_today}.aab"
UI.message("Nom du fichier AAB : #{aab_filename}")

# D√©placer le fichier g√©n√©r√© dans un dossier organis√© avec le nom personnalis√©
sh "mkdir -p ../build_output"
sh "cp ../build/app/outputs/bundle/release/app-release.aab ../build_output/#{aab_filename}"

UI.message("Android AppBundle g√©n√©r√© dans `build_output/#{aab_filename}`")
end

# desc "Construire l'IPA iOS"
# lane :build_ios do
#   # Assurez-vous que le projet Flutter est pr√™t
#
# #   sh "flutter clean"
# #   sh "flutter pub get"
# #   sh "flutter build ios"
#   sh "flutter build ipa --release"
#
#   # Construire l'IPA √† partir du projet iOS Flutter
#   # Param√®tres de signature
#   sign_command = "xcodebuild -workspace ../ios/Runner.xcworkspace -scheme Runner -configuration Release -archivePath ../build/ios/archive/Runner.xcarchive archive"
#   sh sign_command
#
#      # Extraire la version et le code de version depuis pubspec.yaml
#         version = get_version_from_pubspec
#         version_name = version[:version_number]
#         version_code = version[:build_number]
#
#         # Obtenez la date du jour sous forme de AAAAMMJJ (ex. : 24122024 pour 24 d√©cembre 2024)
#             date_today = Time.now.strftime("%d%m%Y")
#
#         # Cr√©er le nom du fichier IPA avec la version
#         ipa_filename = "MeteoApp_#{version_name}+#{version_code}_#{date_today}.ipa"
#         UI.message("Nom du fichier IPA : #{ipa_filename}")
#
#         # D√©placer le fichier g√©n√©r√© dans un dossier organis√© avec le nom personnalis√©
#         sh "mkdir -p ../build_output"
#         sh "cp ../build/ios/ipa/*.ipa ../build_output/#{ipa_filename}"
#
#         UI.message("IPA iOS g√©n√©r√© dans `build_output/#{ipa_filename}`")
#
#   # Exporter l'IPA sign√©
# #           export_command = "xcodebuild -exportArchive -archivePath ./build/ios/archive/Runner.xcarchive -exportPath ./build/ios/ipa -exportOptionsPlist ./ios/ExportOptions.plist"
# #           sh export_command
#
#   UI.message("Fichier IPA g√©n√©r√© dans build/ios/ipa/Runner.ipa")
# end

desc "D√©ployer l'IPA sur TestFlight"
lane :deploy_to_testflight do
  version = get_version_from_pubspec
  version_name = version[:version_number]
  version_code = version[:build_number]



  ipa_dir = "../build_output"
  ipa_filename = Dir.glob("#{ipa_dir}/*#{version_name}+#{version_code}_*.ipa").first

  # Lister tous les fichiers pour diagnostic
    UI.message("Recherche d'IPA dans le dossier : #{ipa_dir}")
    all_files = Dir.glob("#{ipa_dir}/*")
    UI.message("Fichiers trouv√©s : #{all_files.join("\n")}")

  unless ipa_filename
    UI.user_error!("Impossible de trouver un fichier IPA correspondant √† la version #{version_name}+#{version_code} dans le dossier `build_output`.")
  end

  UI.message("D√©ploiement de l'IPA : #{ipa_filename} sur TestFlight")

  upload_to_testflight(
    ipa: ipa_filename,
    skip_waiting_for_build_processing: false
  )

  UI.success("D√©ploiement sur TestFlight termin√© avec succ√®s!")
end

desc "Construire et (optionnellement) d√©ployer l'IPA iOS sur TestFlight"
lane :build_ios do
  # Nettoyer et pr√©parer le projet Flutter
#   sh "flutter clean"
#   sh "flutter pub get"
#   sh "flutter build ios"
  sh "flutter build ipa --release"

  # Commande de signature
  sign_command = "xcodebuild -workspace ../ios/Runner.xcworkspace -scheme Runner -configuration Release -archivePath ../build/ios/archive/Runner.xcarchive archive"
  sh sign_command

  # Extraire la version et le code de version depuis pubspec.yaml
  version = get_version_from_pubspec
  version_name = version[:version_number]
  version_code = version[:build_number]

  # Obtenez la date du jour sous forme de JJMMYYYY
  date_today = Time.now.strftime("%d%m%Y")

  # Cr√©er le nom du fichier IPA avec la version
  ipa_filename = "MeteoApp_#{version_name}+#{version_code}_#{date_today}.ipa"
  UI.message("Nom du fichier IPA : #{ipa_filename}")

  # D√©placer le fichier g√©n√©r√© dans un dossier organis√© avec le nom personnalis√©
  sh "mkdir -p ../build_output"
  sh "cp ../build/ios/ipa/*.ipa ../build_output/#{ipa_filename}"

  UI.message("IPA iOS g√©n√©r√© dans `build_output/#{ipa_filename}`")

  # Demander si l'utilisateur veut d√©ployer sur TestFlight
  deploy_to_testflight = UI.input("Voulez-vous d√©ployer sur TestFlight ? (yes/no)").strip.downcase

  if deploy_to_testflight == "yes"
    # D√©ployer sur TestFlight
    pilot(
      ipa: "../build_output/#{ipa_filename}",
      skip_submission: true,         # Sauter la soumission √† App Store Review
      distribute_external: false,    # Tester uniquement en interne
      changelog: "Version #{version_name}, build #{version_code} - Compil√© le #{date_today}."
    )
    UI.success("Application d√©ploy√©e sur TestFlight avec succ√®s üéâ")
  else
    UI.important("D√©ploiement sur TestFlight annul√©.")
  end
end

# M√©thode pour extraire la version et le num√©ro de build depuis pubspec.yaml
private_lane :get_version_from_pubspec do
  pubspec_path = "../pubspec.yaml"
  pubspec = YAML.load_file(pubspec_path)

  version_string = pubspec["version"]
  version_parts = version_string.split('+')

  {
    version_number: version_parts[0],
    build_number: version_parts[1]
  }
end



lane :increment_version do
  require 'yaml'

  pubspec_path = '../pubspec.yaml'

  # Lire tout le fichier en m√©moire
  lines = File.readlines(pubspec_path)

  # Trouver et extraire la version et le num√©ro de build actuel
  version_info = nil
  lines.each do |line|
    if line.strip.start_with?('version:')
      version_info = line.split(':').last.strip
      break
    end
  end

  version, build_number = version_info.split('+')
  build_number = build_number.to_i

  # Afficher la version et le build actuel
  UI.message("Version actuelle : #{version}+#{build_number}".red)

  # Demander si on souhaite modifier le num√©ro de build uniquement
  modify_build_only = prompt(
    text: "Voulez-vous modifier le num√©ro de build ? (yes/no)",
    boolean: true
  )

  if modify_build_only
    # Demander si on souhaite aussi changer le num√©ro de version
    modify_version = prompt(
      text: "Voulez-vous aussi changer le num√©ro de version actuel (#{version}) ? (yes/no)",
      boolean: true
    )

    # Modifier la version si n√©cessaire
    if modify_version
      version_parts = version.split('.').map(&:to_i)
      version_parts[2] += 1 # Incrementer le patch (x.y.z)
      version = version_parts.join('.')
    end

    # Incr√©mentation du num√©ro de build
    build_number += 1
  else
    UI.message("Aucune modification apport√©e.")
    return
  end

  # Afficher le num√©ro de version et build modifi√©
  UI.message("Nouvelle version : #{version}+#{build_number}".red)

  # R√©√©crire le fichier avec la ligne modifi√©e
  lines.map! do |line|
    if line.strip.start_with?('version:')
      "version: #{version}+#{build_number}\n"
    else
      line
    end
  end

  # R√©√©crire le fichier avec la ligne modifi√©e
  File.write(pubspec_path, lines.join)
  UI.message("Fichier pubspec.yaml mis √† jour avec succ√®s.")
end

desc "Incr√©menter la version et construire Android et iOS"
lane :all do
  increment_version
  build_ios
  build_android
end

# Fonction pour obtenir la version depuis pubspec.yaml
def get_version_from_pubspec
  require 'yaml'

  # Charger le fichier pubspec.yaml
  pubspec_path = '../pubspec.yaml'
  pubspec = YAML.load_file(pubspec_path)

  # Extraire la version et le code de version
  version = pubspec['version'].split('+')
  version_number = version[0] # Partie x.y.z
  build_number = version[1].to_i

  return { version_number: version_number, build_number: build_number }
end